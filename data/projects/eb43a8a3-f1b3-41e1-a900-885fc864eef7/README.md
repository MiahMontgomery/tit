# Project eb43a8a3-f1b3-41e1-a900-885fc864eef7

## Overview
This project was automatically generated by the Titan Autonomous System based on your requirements.

## Feature: Load balancing and high availability setup
Load balancing and high availability setup has been implemented as part of this project.

## Project Details
- **Project ID**: eb43a8a3-f1b3-41e1-a900-885fc864eef7
- **Generated**: 2025-09-29T18:43:49.163Z
- **System**: Titan Autonomous System

## Original Prompt
```
person.ai


role
act as senior engineer. implement personai (a titan sub-system) as a full production-capable project. personai is a platform for creating, training, and running personas—separate entities that autonomously generate outputs, manage workflows, and produce income.

purpose
personai extends titan into humanlike automation. each persona is its own entity with:
- distinct identity and role (manager, worker, performer, friend, etc.)
- its own playwright browser context (userdatadir)
- its own memory (style, preferences, learned facts)
- its own elevenlabs voice agent (unique voice bubble)
- its own evidence feed and input stream
- its own quotas of daily tasks (posts, dms, proposals, deliverables)

personai must scale to dozens of personas. each must operate in strict isolation but within one unified dashboard. it must remain visually identical to titan in styling, layout, and color scheme.

high-level capabilities
1. persona lifecycle
   - create persona with name, role, voiceagentid, apikeys
   - resume/pause persona
   - attach personaprofile (styleprimer, do/dont, topics, signaturephrases)
   - store per-persona memory and recall on every job
2. persona execution
   - run goals via playwright, ai composition, io jobs
   - daily quotas: 2–4 posts, 200–500 dms, 10–20 proposals, 1–2 deliverables
   - proof-first: screenshot, log, file artifacts emitted as evidence
   - error handling: backoff, retry, circuit-breaker on repeated failures
3. persona interaction
   - unique route `/personas/:slug` renders personapage
   - each personapage mounts exactly one elevenlabs voice bubble
   - input tab shows evidence and messages for that persona
   - evidence collapsible blocks identical to titan input
4. persona reporting
   - status/metrics per persona
   - nightly digest with counts (posts, dms, proposals, errors)
   - evidence-first reporting; never fake
5. system scale
   - active_personas global cap (env)
   - per-persona mutex = 1 running goal at a time
   - registry tracks all personas, profiles, goals, outputs

ui requirements
- personai must look and feel **identical** to titan. same colors, same components, same style.
- add a new entry in the titan dashboard nav: **persona**.
- when clicked, it opens a dashboard structured like titan’s project dashboard:
  - heading: “persona”
  - each persona displayed as a rectangular card with system status light
  - add button in top right: “addpersona” (mirrors addproject flow)
- clicking a persona card expands it into tabs, exactly mirroring titan’s layout:
  - progress tab: features, milestones, goals → adapted as persona profile, tasks, quotas
  - input tab: conversation + evidence feed for that persona
  - logs tab: job executions, rollbacks, errors
  - output tab: content or deliverables created by that persona
  - settings tab: persona profile + api keys
- routes must be distinct: `/personas/:slug` (not `/projects/:id`) so elevenlabs can distinguish allowed origins.
- no css changes. reuse titan’s components and styles. only text/labels differ (persona vs project, addpersona vs addproject).

data model (shared/schema.ts with zod)
- persona { id, slug, name, role, voiceagentid?, apikeys?, userdatadir, status, createdat }
- personaprofile { personaid, styleprimer, do[], dont[], topics[], signaturephrases[], temperature?, lengthtargets? }
- goal { id, personaid, type, payload, status, attempts, lasterror?, updatedat }
- evidenceevent { id, personaid?, goalid?, kind, summary, data?, createdat }

backend services
- server/routes/personas.ts: crud for persona + profile + pause/resume
- server/runner/: queue, executor, index tick every 30s, enforce active_personas cap
- server/play/: service.ts (singleton browser, per-persona context), actions.ts (goto, type, click, waitforselector, screenshot, expect*)
- server/services/evidence.ts: log evidence + push input message
- server/services/persona_memory.ts: store/retrieve personaprofile
- server/services/tts_elevenlabs.ts: generate voice audio, cache per persona, log evidence
- server/jobs/templates.ts: job templates for posts, dms, proposals, reports
- server/scheduler/: hourly big-3 per persona, nightly digest

observe endpoints
- get /healthz -> {ok:true}
- get /version -> {version:...}
- get /status (bearer status_token) -> {activepersonas, cap, queuedepths, lastdeploy}
- get /metrics (bearer) -> {poststoday, dmstoday, proposalstoday, errors24h}
- get /logs/tail?lines=200 (bearer) -> last 200 lines

error handling
- backoff schedule: 1m, 5m, 15m; maxattempts=3 → failed
- circuit-breaker: 3 consecutive fails → persona paused, alert emitted
- host allow-list (allowed_hosts) enforced
- rate limits: per persona, per action type
- no faked outputs; only real evidence marks done

verification
- `npm run build && npx tsc --noemit` → 0
- post /api/personas -> create persona; slug unique; userdatadir assigned
- ui: click persona → persona dashboard identical to titan project dashboard, but with persona-specific labels
- open /personas/:slug -> elevenlabs bubble loads, input shows messages/evidence
- seed a goal -> screenshot and logs appear as collapsible evidence items
- scheduler emits nightly digest evidence

deliverables
- list of new/modified files
- example curl commands and outputs
- screenshots of input with evidence blocks
- verification logs
role
act as lead engineer. build personai (a titan sub-system) as a complete, production-capable project. personai is not “an engineer”; it is a system that births, trains, and runs many personas as separate entities that produce outputs and income autonomously.

non-negotiables
- no changes to existing visuals/css/classnames or existing component props.
- additive files/routes/services only.
- typescript compile must be clean: `npx tsc --noemit` = 0.
- evidence-first: no progress without receipts (execution logs/screenshots/files).
- isolation per persona: own playwright profile, own memory, own elevenlabs voice.
- unique route per persona so elevenlabs widget can mount on a distinct, whitelisted url.
- safe by default: rate-limiters, host allow-list, backoff, circuit-breakers.

high-level capabilities
personai must:
1) create and manage many personas (dozens) concurrently with isolation.
2) for each persona, run daily quotas of social posts/dms/proposals/deliverables.
3) autonomously compose content (text/audio/video prompts), post, dm, submit proposals, and attach proof.
4) learn: store voice/style/memory per persona and retrieve that context on every action.
5) recover: handle errors, backoff, retry, and mark failed with reasons; never fake success.
6) scale: global active_personas cap, per-persona mutex=1 job at a time; persistent storage for profiles and artifacts.
7) observe: status/metrics endpoints, logs tail, and per-project/persona evidence feed.

output requirements
- for each persona, personai must produce daily:
  - posts (2–4/day) with screenshot proof and link.
  - dms/outreach (200–500/day for performer personas) with send logs.
  - proposals (10–20/day for worker personas) with submission screenshots/csv.
  - deliverables (files/links) with proof of upload/sent.
- all outputs must write evidenceevent rows and emit a message into the input stream with `metadata: {type:'screenshot'|'execution'|'file', ...}`.

skeleton to scaffold (add files/routes only)

1) data model (shared/schema.ts with zod & types)
- persona {
    id: string,
    slug: string,              // unique, used in route (/personas/:slug)
    name: string,
    projectid?: string,
    role: 'manager'|'worker'|'performer'|'friend',
    voiceagentid?: string,     // elevenlabs
    apikeys?: record<string,string>, // per-persona keys
    userdatadir: string,       // playwright profile path
    status: 'active'|'paused',
    createdat: string
  }
- personaprofile {
    personaid: string,
    styleprimer: string,       // 2–3k chars style guide
    do: string[], dont: string[],
    topics: string[],
    signaturephrases: string[],
    temperature?: number,
    lengthtargets?: {short:number, long:number}
  }
- goal {
    id: string,
    personaid: string,
    projectid?: string,
    type: 'browser'|'io'|'ai'|'report',
    payload: unknown,          // job-specific json
    status: 'pending'|'running'|'done'|'failed',
    attempts: number,
    lasterror?: string,
    updatedat: string
  }
- evidenceevent {
    id: string,
    projectid?: string,
    personaid?: string,
    goalid?: string,
    kind: 'log'|'http'|'screenshot'|'file'|'execution',
    summary: string,
    data?: unknown,            // may include filepath, url, status
    createdat: string
  }

2) env / config (server reads on boot; create defaults)
- active_personas=8
- playwright_root=/var/titan/personas        // per-persona profile root
- titan_data_root=/var/titan/data
- allowed_hosts=outlook.live.com,linkedin.com,tiktok.com,instagram.com,upwork.com,fiverr.com,reddit.com,youtube.com,replit.com
- status_token=<long random>                 // protects read endpoints
- elevenlabs_api_key (present but stored per persona in apikeys too)
- openrouter_api_key (present but stored per persona in apikeys too)

3) persona registry (server/routes/personas.ts)
- post /api/personas
  - body {name, role, voiceagentid?, apikeys?}
  - creates persona; generates slug (kebab-case unique); assigns `userdatadir = ${playwright_root}/${id}`
  - creates default personaprofile with blank primer if absent
- get /api/personas/:slug
- post /api/personas/:slug/pause
- post /api/personas/:slug/resume
- post /api/personas/:slug/profile  // update styleprimer/do/dont/topics/signatures

4) unique routing for elevenlabs (client)
- new route: `/personas/:slug` => client/src/pages/personapage.tsx
  - mount exactly one elevenlabs widget using persona.voiceagentid
  - bind existing inputcontext to current persona (messages/evidence)
  - no style or prop changes; reuse existing components
- note: if subdomain is easier for whitelist, also add server support for `p-<slug>.yourdomain.com` resolving to the same personapage (optional, additive).

5) runner & queues (server/runner/{index.ts,queue.ts,executor.ts})
- global cap: active_personas (read from env); persona mutex=1 running at a time
- queue.ts: fifo per persona; atomic claim; store running → done/failed
- index.ts: tick every 30s; pick up to active_personas personas; for each, if not running, claim one pending goal; call executor; write evidence; apply backoff on failures (1m, 5m, 15m), maxattempts=3 then mark failed
- executor.ts:
  - types of jobs:
    * 'browser' => go through playwright actions (below), assert expectations
    * 'ai' => compose text using persona profile + memory; emit execution/file artifacts
    * 'io' => write files (e.g., csv append for proposals, rendered captions)
    * 'report' => aggregate day stats for digest
  - on every step, call evidence.log(...) and post input message with metadata
  - never set done unless assertions pass; else failed with lasterror

6) playwright bridge (server/play/{service.ts,actions.ts})
- service.ts: singleton browser; per job createcontext with `userdatadir = persona.userdatadir`; reject if host not in allowed_hosts
- actions.ts:
  - goto(url)
  - type(selector,text)
  - click(selector)
  - waitforselector(selector, timeout?)
  - screenshot(name) -> filepath under `${titan_data_root}/evidence/${personaid}/...`
  - expecttitlecontains(str)
  - expectselector(selector)
- every action emits evidenceevent (kind='execution' or 'screenshot') with details

7) memory & voice (server/services)
- services/persona_memory.ts:
  - `upsertprofile(personaid, profiledata)`
  - `retrievestyle(personaid)` returns styleprimer + signaturephrases + do/dont + topics
  - optional: embeddings later; keep api stable
- services/tts_elevenlabs.ts:
  - `speak(personaid, text)` -> mp3 cached at `${titan_data_root}/voices/${personaid}/...`, return filepath; emit evidenceevent(kind='file')
  - use persona.voiceagentid primarily; fallback to env key

8) daily job templates (server/jobs/templates.ts)
define minimal templates; the runner will schedule these:
- worker.submitproposal(niche, platform) -> 'browser' script: goto job board, fill, submit, screenshot, csv append
- social.post(platform, assetspec) -> compose(text via 'ai') -> render asset (stub) -> 'browser' upload -> screenshot -> link
- perf.senddm(platform, batchsize) -> iterate, send, log
- report.dailydigest -> compile counts; emit input message

9) scheduler (server/scheduler/index.ts)
- hourly: score pending goals per persona; enqueue top 3 (big-3)
- nightly: emit dailydigest report evidence/message per persona
- respect active_personas and persona status

10) evidence service (server/services/evidence.ts)
- `log({personaid, goalid, kind, summary, data?})` → write evidenceevent; also push a message into input with `metadata`:
  - execution: { step, ok, details }
  - screenshot: { filepath, caption }
  - file: { filepath, description }

11) prod observe (server/routes/status.ts)
- get /healthz -> {ok:true}
- get /version -> {version: process.env.git_sha ?? 'dev'}
- get /status (bearer status_token) -> {activepersonas, cap, queuedepths, lastdeploy}
- get /metrics (bearer) -> {poststoday, dmstoday, proposalstoday, errors24h}
- get /logs/tail?lines=200 (bearer) -> last lines from pino log

12) dev seed helpers (server/routes/seed.ts; behind allow_seed=true)
- post /dev/seed/persona {name,role,voiceagentid,apikeys} -> create persona
- post /dev/seed/goal {personaid,type,payload} -> insert pending goal
- useful for first proof

13) error handling & safety
- backoff schedule: 1m → 5m → 15m; maxattempts=3 → failed
- circuit-break: if a persona has 3 consecutive failed goals, set status='paused' and emit alert message
- rate limits:
  - per persona per site qps ~ 0.2–0.5
  - global posts/day, dms/day caps via scheduler
- host allow-list enforcement; reject actions to non-whitelisted hosts
- never access prod `.env` via endpoints; secure all read routes with bearer token

routing for elevenlabs (required)
- use unique persona routes `/personas/:slug` to avoid widget confusion
- if elevenlabs requires explicit allowed origins/urls, prepare to register:
  - `https://yourdomain.com/personas/:slug`
  - (optional) `https://p-:slug.yourdomain.com/` subdomains if needed; add server support to resolve to personapage

verification (cursor must return outputs + file list)
1) build & typecheck: `npm run build && npx tsc --noemit` => 0
2) start server; create a persona via:
   curl -x post /api/personas -d '{"name":"livia","role":"manager","voiceagentid":"<id>","apikeys":{"openrouter":"...","elevenlabs":"..."}}'
3) open `/personas/livia` -> one elevenlabs widget mounted; input shows thread
4) seed goals:
   - livia: 'browser' payload => goto('https://outlook.live.com'); waitforselector(...); screenshot('outlook.png'); expecttitlecontains('outlook')
   - jason: 'ai' payload => compose "master note outline v0" using profile; emit file evidence
5) runner executes within 30s; input shows execution + screenshot/file receipts; evidence files exist under `${titan_data_root}/evidence/...`
6) /status and /metrics return sensible json with token

deliverables
- list of new/modified files
- exact curl commands used and their outputs
- logs indicating evidenceevent writes and file paths
- confirmation that persona isolation (userdatadir) is per-persona
```

## Getting Started

### Prerequisites
- Node.js (if applicable)
- npm or yarn (if applicable)

### Installation
```bash
# If this is a Node.js project
npm install

# If this is a Python project
pip install -r requirements.txt
```

### Running the Project
```bash
# For Node.js projects
npm start

# For Python projects
python server.py

# For static HTML projects
# Simply open index.html in your browser
```

## Project Structure
```
project-eb43a8a3-f1b3-41e1-a900-885fc864eef7/
├── src/                 # Source code
├── public/              # Static assets
├── package.json         # Dependencies (if applicable)
├── README.md           # This file
└── ...                 # Other generated files
```

## Features Implemented
- Load balancing and high availability setup
- Additional features as specified in the original prompt

## Development
This project was generated automatically. You can modify and extend it as needed.

## Support
For questions about this project, refer to the Titan Autonomous System documentation.

---
*Generated by Titan Autonomous System on 2025-09-29T18:43:49.163Z*